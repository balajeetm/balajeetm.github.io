---
layout: post
title: WTF in Agile
date: 2017-03-14 19:19
comments: true
external-url:
categories: Microservices
---


>Software engineering process has become synonymous to using Agile methodologies in the contemporary era.<br>
Almost every enterprise is using it nowadays.<br>
But [WTF](/blog/2017/02/13/welcome-aboard/) in Agile?<br>


**Why Agile?**<br>

Software engineering is a stream of engineering. Is there any other stream in which such philosophies are followed?<br>
Mechanical and Civil Engineering for eg are way matured in their process flow, which btw, has evolved over time.<br>
How does Agile find its place in this ocean of options?<br>

## The Perils of Engineering Streams
<hr>

Software Engineering is unlike any other stream of engineering.<br>
It's different from Civil Engineering where we erect enormous structures (skyscrapers, bridges, dams, etc),<br>
or Mechanical Engineering where we build products and machineries (cars, turbines, etc)<br>

_**How is it different, you ask aye?**_

### <u>Stages of Product Engineering</u>

The typical stages of product engineering is as below

```
Plan -> Build -> Maintain
```

Let's look at the cost of these stages as a function of time.<br>
For let's say constructing a skyscraper.<br>

<img src="/assets/2017-03-14/cost.png">

The cost, during planning is negligible because there are very few people doing it and also, we do not procure any material as such.<br>
It increases substantially once we begin building it, owing labour, material and other procurement costs.<br>
The cost of maintenance is much lesser compared to the cost of building of course.<br>

Another thing that stands out in the diagram is that a lot of time is spent in Planning.<br>
**But why so?**

To answer that, let's try to understand when the product actually delivers some value.<br>
We'll update the diagram to reflect the value of product over time.<br>

<img src="/assets/2017-03-14/value.png">

### <u>The Risk</u>

So we see, the skyscraper is only valuable when it's completed and ready for the world to use.<br>
Until then?<br>
All the investment of time and effort is a risk.<br>

**Which is why a lot of time is spent in planning, just to ensure these risks are mitigated.**<br>

Remember... these risks are extremely expensive…<br>
Because, the cost of change during the later part of the build stage or maintenance stage is humungous.<br>
This includes cost in time, as well as money.<br>
You cannot remove a floor after its built, can you?<br>
There is very little flexibility for change in the later stages of the lifecycle.<br>

This is why a lot of time is spent in planning to ensure that all edge cases are covered and risks are captured.<br>
Subsequently, these risks are analyzed and a strategy is hatched to prevent or overcome these risks.<br>
Now that takes time… a lot of time.<br>
Lots and lots of time.<br>

## The Uniqueness of Software Engineering
<hr>

Software products thankfully are unlike any sky scrappers.<br>
That's obvious, because they go beyond these towers, and reach the cloud !!!<br>

Jokes apart, software has two distinctive USPs
* Low Cost to Change
* Low Cost to Distribute

### <u>Feedback from Users</u>

Because software has very **"Low cost of distribution"**, we can share it with the world very quickly.<br>

Remember, how easy it is for us to install a new app on the phone or a new software on our laptops.<br>
And with tons of new ones coming out each day, its just exciting for many "app-buffs" to try them all out.<br>

The users of our software, thus use them and provide us with invaluable feedback.<br>
This feedback helps us identify the risks in our design early.<br>
We can have this feedback drive our innovation by incorporating the learnings into our design.<br>

Now, because software also has **"Low cost to change"**, we can implement the learnings rapidly.<br>
We can break the learnings into smaller usable features and work on them in a iterative fashion.<br>

And, continuously distribute it to our users who can use them and revert with feedbacks.<br>
Once again, we can fuel this feedback into our iterative development.<br>

Now we enter the age of Rapid Iterative Development with continuous feedback.<br>
We enter the **"Age of Agile Development"** with continuous improvement<br>

So, we transform from this to this<br>


So we are able to deliver value incrementally unlike in any other engineering stream.<br>
This not just lowers risk for we also have umpteen opportunities to course correct.<br>








